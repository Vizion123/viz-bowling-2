<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Viz Bowling</title>
  <style>
    :root { --bg:#0b1b34; --bg2:#193a60; --btn:#ffffff; --btnBorder:#cfd6e4;}
    html, body { height: 100%; margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(180deg, var(--bg), var(--bg2)); color: #fff; }
    .wrap { display: flex; align-items: center; justify-content: center; padding: 20px; }
    .panel { width: min(920px, 96vw); text-align: center; }
    h1 { margin: 6px 0 2px; font-size: 28px; }
    .hud { opacity: .9; font-size: 14px; margin-bottom: 8px; }
    canvas { width: 100%; height: auto; border-radius: 16px; background: transparent; box-shadow: 0 10px 30px rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.2); }
    .msg { margin: 10px auto 12px; font-size: 14px; opacity: .95; }
    .controls { display:flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: center; }
    button { padding: 8px 12px; border-radius: 12px; background: var(--btn); color:#111; border:1px solid var(--btnBorder); cursor:pointer; }
    button:hover { filter: brightness(1.03); }
    .pill { display:inline-block; padding:.15rem .5rem; background:rgba(255,255,255,.15); border-radius:999px; font-size:12px; margin:0 4px; }
    .footer { font-size: 12px; opacity: .7; margin-top: 10px;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Viz Bowling</h1>
    <div id="hud" class="hud"></div>
    <canvas id="game" width="800" height="560"></canvas>
    <div id="msg" class="msg"></div>
    <div class="controls">
      <button id="aimL">‚Üê Aim</button>
      <button id="aimR">Aim ‚Üí</button>
      <button id="powM">Power ‚àí</button>
      <button id="powP">Power +</button>
      <button id="roll">üé≥ Roll</button>
      <button id="reset">‚Üª Reset Roll</button>
      <button id="new">New Game</button>
    </div>
    <div class="footer">
      Controls: <span class="pill">‚Üê ‚Üí aim & move start</span> <span class="pill">‚Üë ‚Üì power</span> <span class="pill">Space roll</span> <span class="pill">R reset</span> <span class="pill">Enter next frame</span> <span class="pill">N new game</span>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');
  const W = canvas.width, H = canvas.height;

  // Lane interior x-bounds are [160, 640]; keep the ball radius inside that.
  const BALL_R = 16;
  const MIN_X = 160 + BALL_R; // 176
  const MAX_X = 640 - BALL_R; // 624

  // State
  let aim = 0;               // -25..25 deg
  let power = 60;            // 30..100
  let rolling = false;
  let frame = 1, rollInFrame = 1, score = 0;

  // Starting position (immediate movement with arrows/buttons)
  let startX = 400;          // current starting X of Viz

  let pins = makePins();
  let ball = makeBall();

  // Utils
  const clamp = (n,a,b) => Math.max(a, Math.min(b, n));
  const map = (n,a1,a2,b1,b2) => b1 + ((n-a1)*(b2-b1))/(a2-a1);

  function setMessage(t){ msg.textContent = t; }
  function updateHUD(){ hud.textContent = `Frame ${frame} ‚Ä¢ Roll ${rollInFrame} ‚Ä¢ Score ${score} ‚Ä¢ Aim ${aim|0}¬∞ ‚Ä¢ Power ${power}%`; }

  function makeBall(){ return { x: startX, y: 520, vx:0, vy:0, r:BALL_R, active:false }; }

  function newFrame(resetAll=false){
    if (resetAll){ frame = 1; score = 0; }
    rollInFrame = 1;
    pins = makePins();
    // keep chosen startX when starting new frame
    ball = makeBall();
    rolling = false;
    setMessage('Aim with ‚Üê ‚Üí (moves Viz), set power with ‚Üë ‚Üì, SPACE to roll');
  }

  function makeRoll(){
    // Block if still rolling or strike already cleared all pins
    if (rolling || pins.every(p=>p.knocked)) return;
    const speed = map(power, 30, 100, 4.2, 8.2);
    const angle = aim * Math.PI / 180;
    ball.vx = Math.sin(angle) * speed;
    ball.vy = -Math.cos(angle) * speed;
    ball.active = true;
    rolling = true;
    setMessage('Rolling‚Ä¶ press R to reset if stuck');
  }

  // Input (keyboard)
  window.addEventListener('keydown', e => {
    if (e.repeat) return;

    if (e.key === 'ArrowLeft') {
      aim = clamp(aim - 3, -25, 25);
      startX = clamp(startX - 20, MIN_X, MAX_X); // move Viz left
      if (!ball.active) ball.x = startX;         // update visible ball position when idle
    }

    if (e.key === 'ArrowRight') {
      aim = clamp(aim + 3, -25, 25);
      startX = clamp(startX + 20, MIN_X, MAX_X); // move Viz right
      if (!ball.active) ball.x = startX;
    }

    if (e.key === 'ArrowUp')   power = clamp(power + 5, 30, 100);
    if (e.key === 'ArrowDown') power = clamp(power - 5, 30, 100);

    if (e.key === ' '){ makeRoll(); e.preventDefault(); }
    if (e.key.toLowerCase() === 'r'){ newFrame(); }
    if (e.key === 'Enter'){ if (!rolling && !ball.active){ frame++; newFrame(); } }
    if (e.key.toLowerCase() === 'n'){ newFrame(true); }
  });

  // Input (buttons)
  document.getElementById('aimL').onclick = () => {
    aim = clamp(aim - 3, -25, 25);
    startX = clamp(startX - 20, MIN_X, MAX_X);
    if (!ball.active) ball.x = startX;
  };
  document.getElementById('aimR').onclick = () => {
    aim = clamp(aim + 3, -25, 25);
    startX = clamp(startX + 20, MIN_X, MAX_X);
    if (!ball.active) ball.x = startX;
  };
  document.getElementById('powM').onclick = () => { power = clamp(power - 5, 30, 100); };
  document.getElementById('powP').onclick = () => { power = clamp(power + 5, 30, 100); };
  document.getElementById('roll').onclick = () => { makeRoll(); };
  document.getElementById('reset').onclick = () => { newFrame(); };
  document.getElementById('new').onclick = () => { newFrame(true); };

  // Main loop
  function loop(){
    // Physics when rolling
    if (ball.active){
      ball.x += ball.vx; ball.y += ball.vy;

      // Lane borders
      if (ball.x < 160 + ball.r){ ball.x = 160 + ball.r; ball.vx *= -0.7; }
      if (ball.x > 640 - ball.r){ ball.x = 640 - ball.r; ball.vx *= -0.7; }

      // friction + tiny hook based on aim
      ball.vx *= 0.996; ball.vy *= 0.998;
      ball.vx += Math.sin(aim*Math.PI/180) * 0.015;

      // collisions with pins
      for (const p of pins){
        if (p.knocked) continue;
        const dx = ball.x - p.x, dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.r + p.r){
          p.knocked = true; p.vx = dx*0.25; p.vy = dy*0.25;
        }
      }

      // reached the end of lane
      if (ball.y < 90){
        const knockedNow = pins.filter(p=>p.knocked).length;
        const standing = 10 - knockedNow;
        let message = `${knockedNow} pin${knockedNow===1?'':'s'}!`;
        let advanceFrame = false;

        if (rollInFrame === 1){
          if (standing === 0){
            score += 10; message = 'STRIKE! 10 points'; advanceFrame = true;
          } else {
            // Prepare second roll
            rollInFrame = 2;
            message += ' Roll 2: move/aim & SPACE to roll again';
            ball = makeBall();     // respawn at current startX
            rolling = false;       // allow Space to trigger
            ball.active = false;   // ensure idle state
          }
        } else {
          // second roll (simple scoring: add total pins knocked this frame)
          score += knockedNow;
          advanceFrame = true;
        }

        if (advanceFrame){
          if (frame >= 10){
            setMessage(message + ' | Game Over ‚Äî press N to start new game');
          } else {
            setMessage(message + ` | Frame ${frame+1} next (press ENTER)`);
          }
          rolling = false;
        } else {
          setMessage(message);
        }
      }
    }

    // drift knocked pins
    for (const p of pins){
      if (!p.knocked) continue;
      p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98;
    }

    // Draw
    ctx.clearRect(0,0,W,H);
    drawBackground(ctx);
    drawLane(ctx);
    drawPins(ctx, pins);
    drawBall(ctx, ball);
    drawHUD(ctx);

    updateHUD();
    requestAnimationFrame(loop);
  }

  // Drawing
  function drawBackground(ctx){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0b1b34'); g.addColorStop(1, '#193a60');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }

  function drawLane(ctx){
    // gutters
    ctx.fillStyle = '#0a1020';
    ctx.fillRect(120,80,40,440);
    ctx.fillRect(640,80,40,440);

    // wood lane
    const laneGrad = ctx.createLinearGradient(160,520,640,80);
    laneGrad.addColorStop(0,'#d9a86c'); laneGrad.addColorStop(1,'#c58b49');
    ctx.fillStyle = laneGrad;
    ctx.fillRect(160,80,480,440);

    // approach
    ctx.fillStyle = '#8b5e34';
    ctx.fillRect(160,520,480,24);

    // center line
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.setLineDash([8,12]);
    ctx.beginPath(); ctx.moveTo(400,520); ctx.lineTo(400,92); ctx.stroke();
    ctx.setLineDash([]);

    // festive lights
    ctx.save(); ctx.translate(160,72);
    for (let i=0;i<16;i++){ const x=(i/15)*480;
      ctx.fillStyle = ['#ffd166','#ef476f','#06d6a0','#118ab2'][i%4];
      ctx.beginPath(); ctx.arc(x,0,4,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawPins(ctx, ps){
    for (const p of ps){
      ctx.save(); ctx.translate(p.x, p.y);
      if (p.knocked) ctx.rotate((p.vx+p.vy)*0.08);
      // body
      roundRect(ctx,-10,-24,20,44,10);
      ctx.fillStyle = '#fff2e0'; ctx.fill();
      // hat
      ctx.fillStyle = '#d1495b'; ctx.beginPath(); ctx.moveTo(0,-32); ctx.lineTo(12,-16); ctx.lineTo(-12,-16); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(0,-32,3,0,Math.PI*2); ctx.fill();
      // face
      ctx.fillStyle = '#42312a'; ctx.beginPath(); ctx.arc(-4,-8,1.5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4,-8,1.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#42312a'; ctx.beginPath(); ctx.arc(0,-2,5,0,Math.PI,false); ctx.stroke();
      // belt
      ctx.fillStyle = '#2a9d8f'; ctx.fillRect(-10,2,20,6);
      ctx.fillStyle = '#f4a261'; ctx.fillRect(-3,3,6,4);
      ctx.restore();
    }
  }

  function drawBall(ctx, b){
    ctx.save(); ctx.translate(b.x, b.y);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(0, b.r*0.6, b.r*1.1, b.r*0.4, 0, 0, Math.PI*2); ctx.fill();
    // body
    const g = ctx.createRadialGradient(-6,-6,2, 0,0,b.r);
    g.addColorStop(0,'#ffffff'); g.addColorStop(1,'#e6ecf6');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    // iris/pupil/highlight
    ctx.fillStyle = '#2b4a73'; ctx.beginPath(); ctx.arc(0,0,b.r*0.55,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#7fb3e4'; ctx.beginPath(); ctx.arc(0,0,b.r*0.35,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0b1730'; ctx.beginPath(); ctx.arc(4,-2,b.r*0.22,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(8,-6,b.r*0.09,0,Math.PI*2); ctx.fill();
    // beanie
    roundRect(ctx,-18,-24,36,12,6); ctx.fillStyle = '#365b2c'; ctx.fill();
    ctx.fillStyle = '#4a7a3a'; ctx.beginPath(); ctx.arc(18,-18,5,0,Math.PI*2); ctx.fill();
    // smile
    ctx.strokeStyle = '#c33'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-2,6,10,0,Math.PI*0.7,false); ctx.stroke();
    ctx.restore();
  }

  function drawHUD(ctx){
    ctx.save(); ctx.fillStyle = '#ffffff'; ctx.font = '14px Inter, system-ui, sans-serif';
    ctx.fillText('Aim: ' + (aim|0) + '¬∞', 10, 20);
    ctx.fillText('Power: ' + power + '%', 10, 40);
    ctx.fillText('Score: ' + score, 10, 60);
    ctx.fillText('Frame ' + frame + ' / 10  ‚Ä¢  Roll ' + rollInFrame, 10, 80);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  function makePins(){
    const ps = []; const startX = 400, startY = 140, spacing = 34;
    for (let row=0; row<4; row++){
      for (let i=0; i<=row; i++){
        const x = startX - row*(spacing/2) + i*spacing;
        const y = startY + row*spacing;
        ps.push({ x, y, r:12, knocked:false, vx:0, vy:0 });
      }
    }
    return ps;
  }

  function start(){
    newFrame(false);
    updateHUD();
    requestAnimationFrame(loop);
  }

  start();
})();
</script>
</body>
</html>
