<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Viz Bowling (Assist Mode)</title>
  <style>
    :root { --bg:#0b1b34; --bg2:#193a60; --btn:#ffffff; --btnBorder:#cfd6e4;}
    html, body { height: 100%; margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(180deg, var(--bg), var(--bg2)); color: #fff; }
    .wrap { display: flex; align-items: center; justify-content: center; padding: 20px; }
    .panel { width: min(920px, 96vw); text-align: center; }
    h1 { margin: 6px 0 2px; font-size: 28px; }
    .hud { opacity: .9; font-size: 14px; margin-bottom: 8px; }
    canvas { width: 100%; height: auto; border-radius: 16px; background: transparent; box-shadow: 0 10px 30px rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.2); }
    .msg { margin: 10px auto 12px; font-size: 14px; opacity: .95; }
    .controls { display:flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: center; }
    button { padding: 8px 12px; border-radius: 12px; background: var(--btn); color:#111; border:1px solid var(--btnBorder); cursor:pointer; }
    button:hover { filter: brightness(1.03); }
    .pill { display:inline-block; padding:.15rem .5rem; background:rgba(255,255,255,.15); border-radius:999px; font-size:12px; margin:0 4px; }
    .footer { font-size: 12px; opacity: .7; margin-top: 10px;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Viz Bowling</h1>
    <div id="hud" class="hud"></div>
    <canvas id="game" width="800" height="560"></canvas>
    <div id="msg" class="msg"></div>
    <div class="controls">
      <button id="aimL">‚Üê Aim</button>
      <button id="aimR">Aim ‚Üí</button>
      <button id="powM">Power ‚àí</button>
      <button id="powP">Power +</button>
      <button id="roll">üé≥ Roll</button>
      <button id="reset">‚Üª Reset Roll</button>
      <button id="new">New Game</button>
    </div>
    <div class="footer">
      Controls: <span class="pill">‚Üê ‚Üí aim & move start</span> <span class="pill">‚Üë ‚Üì power</span> <span class="pill">Space roll</span> <span class="pill">R reset</span> <span class="pill">Enter next frame</span> <span class="pill">N new game</span>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');

  // Geometry
  const BALL_R = 16;
  const MIN_X = 160 + BALL_R; // 176
  const MAX_X = 640 - BALL_R; // 624

  // Assist tuning (üëà tweak these to make it even easier/harder)
  const HOOK_STRENGTH = 0.035;     // was ~0.015 ‚Äî stronger hook
  const FRICTION_X = 0.998;        // was 0.996 ‚Äî keeps speed longer
  const FRICTION_Y = 0.999;        // was 0.998 ‚Äî keeps speed longer
  const HIT_PAD = 6;               // extra pixels to count a "grazing" hit
  const PIN_IMPULSE = 0.35;        // was 0.25 ‚Äî pins fly more
  const PIN_CHAIN_RADIUS = 34;     // neighbors within this get toppled push
  const PIN_CHAIN_IMPULSE = 0.18;  // impulse to neighbors
  const SOFT_AIM_ASSIST = 0.0009;  // subtle correction toward headpin early in lane

  // Game state
  let aim = 0;                 // -25..25 deg
  let power = 60;              // 30..100
  let rolling = false;
  let resolvedThisRoll = false;
  let frame = 1;               // 1..10
  let rollInFrame = 1;
  let startX = 400;

  // Pins + ball
  let pins = makePins();
  let ball = makeBall();

  // Traditional scoring
  let frames = Array.from({length: 10}, () => ({ r1: null, r2: null, r3: null }));
  let totalScore = 0;

  const clamp = (n,a,b) => Math.max(a, Math.min(b, n));
  const map = (n,a1,a2,b1,b2) => b1 + ((n-a1)*(b2-b1))/(a2-a1);
  const setMessage = t => { msg.textContent = t; };
  const updateHUD = () => {
    const f = frames.map((fr,i) => frameString(fr, i)).join(' | ');
    hud.textContent = `Frame ${frame} ‚Ä¢ Roll ${rollInFrame} ‚Ä¢ Score ${totalScore} ‚Ä¢ Aim ${aim|0}¬∞ ‚Ä¢ Power ${power}% | ${f}`;
  };

  function frameString(fr, i){
    const r1 = fr.r1 ?? '-', r2 = fr.r2 ?? '-', r3 = fr.r3 ?? '-';
    if (i < 9) {
      if (fr.r1 === 10) return `F${i+1}: X`;
      if (fr.r1 != null && fr.r2 != null) return `F${i+1}: ${fr.r1 + fr.r2 === 10 ? (fr.r1 + " /") : (fr.r1 + " " + fr.r2)}`;
      if (fr.r1 != null) return `F${i+1}: ${fr.r1}`;
      return `F${i+1}: -`;
    } else {
      return `F10: ${r1} ${r2} ${fr.r3 != null ? r3 : ''}`.trim();
    }
  }

  function makeBall(){ return { x: startX, y: 520, vx:0, vy:0, r:BALL_R, active:false }; }

  function newGame(){
    aim=0; power=60; rolling=false; resolvedThisRoll=false; frame=1; rollInFrame=1;
    startX=400; pins=makePins(); ball=makeBall();
    frames = Array.from({length: 10}, () => ({ r1: null, r2: null, r3: null }));
    totalScore = 0;
    setMessage('Aim with ‚Üê ‚Üí (moves Viz), set power with ‚Üë ‚Üì, SPACE to roll');
  }

  function newFrame(){
    rollInFrame = 1;
    pins = makePins();
    ball = makeBall();
    rolling = false;
    resolvedThisRoll = false;
    setMessage('Aim with ‚Üê ‚Üí (moves Viz), set power with ‚Üë ‚Üì, SPACE to roll');
  }

  function makeRoll(){
    if (rolling) return;
    if (frame < 10 && pins.every(p=>p.knocked)) return;
    const speed = map(power, 30, 100, 4.2, 8.6); // tiny top-speed bump
    const angle = aim * Math.PI / 180;
    ball.vx = Math.sin(angle) * speed;
    ball.vy = -Math.cos(angle) * speed;
    ball.active = true;
    rolling = true;
    resolvedThisRoll = false;
    setMessage('Rolling‚Ä¶ press R to reset if stuck');
  }

  // INPUT
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowLeft') {
      aim = clamp(aim - 3, -25, 25);
      startX = clamp(startX - 20, MIN_X, MAX_X);
      if (!ball.active) ball.x = startX;
    }
    if (e.key === 'ArrowRight') {
      aim = clamp(aim + 3, -25, 25);
      startX = clamp(startX + 20, MIN_X, MAX_X);
      if (!ball.active) ball.x = startX;
    }
    if (e.key === 'ArrowUp')   power = clamp(power + 5, 30, 100);
    if (e.key === 'ArrowDown') power = clamp(power - 5, 30, 100);

    if (e.key === ' ') { makeRoll(); e.preventDefault(); }
    if (e.key.toLowerCase() === 'r') {
      pins = makePins(); ball = makeBall(); rolling=false; resolvedThisRoll=false; rollInFrame = 1;
      setMessage('Frame reset. Aim and roll.');
    }
    if (e.key.toLowerCase() === 'n') { newGame(); }
    if (e.key === 'Enter') {
      if (!rolling && isFrameComplete(frame-1)) {
        if (frame < 10) { frame++; newFrame(); }
        else setMessage('Game Over ‚Äî press N for a new game');
      }
    }
  });

  document.getElementById('aimL').onclick = () => {
    aim = clamp(aim - 3, -25, 25);
    startX = clamp(startX - 20, MIN_X, MAX_X);
    if (!ball.active) ball.x = startX;
  };
  document.getElementById('aimR').onclick = () => {
    aim = clamp(aim + 3, -25, 25);
    startX = clamp(startX + 20, MIN_X, MAX_X);
    if (!ball.active) ball.x = startX;
  };
  document.getElementById('powM').onclick = () => { power = clamp(power - 5, 30, 100); };
  document.getElementById('powP').onclick = () => { power = clamp(power + 5, 30, 100); };
  document.getElementById('roll').onclick = () => { makeRoll(); };
  document.getElementById('reset').onclick = () => {
    pins = makePins(); ball = makeBall(); rolling=false; resolvedThisRoll=false; rollInFrame = 1;
    setMessage('Frame reset. Aim and roll.');
  };
  document.getElementById('new').onclick = () => { newGame(); };

  // LOOP
  function loop(){
    if (ball.active){
      // integrate
      ball.x += ball.vx; ball.y += ball.vy;

      // soft aim assist toward headpin early in lane (y>350)
      if (ball.y > 350 && ball.y < 520){
        const head = { x: 400, y: 140 };
        const dx = head.x - ball.x, dy = head.y - ball.y;
        const d = Math.hypot(dx,dy) || 1;
        ball.vx += (dx/d) * SOFT_AIM_ASSIST * ( (520 - ball.y) / 170 ); // fades out near foul line
      }

      // borders
      if (ball.x < 160 + ball.r){ ball.x = 160 + ball.r; ball.vx *= -0.65; }
      if (ball.x > 640 - ball.r){ ball.x = 640 - ball.r; ball.vx *= -0.65; }
      // friction + stronger hook
      ball.vx *= FRICTION_X; ball.vy *= FRICTION_Y;
      ball.vx += Math.sin(aim*Math.PI/180) * HOOK_STRENGTH;

      // collisions with pins (easier hit detection + stronger impulse + chain reaction)
      for (let i=0; i<pins.length; i++){
        const p = pins[i];
        if (p.knocked) continue;
        const dx = ball.x - p.x, dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.r + p.r + HIT_PAD){
          // topple this pin
          p.knocked = true;
          p.vx = dx * PIN_IMPULSE;
          p.vy = dy * PIN_IMPULSE;

          // chain reaction: nudge nearby pins
          for (let j=0; j<pins.length; j++){
            if (j === i) continue;
            const q = pins[j];
            if (q.knocked) continue;
            const ndx = q.x - p.x, ndy = q.y - p.y;
            const nd = Math.hypot(ndx, ndy);
            if (nd < PIN_CHAIN_RADIUS){
              q.knocked = true;
              q.vx = ndx * PIN_CHAIN_IMPULSE;
              q.vy = ndy * PIN_CHAIN_IMPULSE;
            }
          }
        }
      }

      // resolve once per roll
      if (ball.y < 90 && !resolvedThisRoll){
        resolvedThisRoll = true;

        const knockedNow = pins.filter(p=>p.knocked).length;
        const standing = 10 - knockedNow;

        ball.active = false;
        rolling = false; ball.vx = 0; ball.vy = 0;

        handleRoll(knockedNow, standing);
        recomputeScore();
      }
    }

    // drift knocked pins
    for (const p of pins){
      if (!p.knocked) continue;
      p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98;
    }

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground(ctx);
    drawLane(ctx);
    drawPins(ctx, pins);
    drawBall(ctx, ball);
    drawHUD(ctx);

    updateHUD();
    requestAnimationFrame(loop);
  }

  // ROLL / FRAME / SCORING
  function handleRoll(knockedNow, standing){
    const fi = frame - 1;
    const fr = frames[fi];

    if (frame <= 9){ // Frames 1‚Äì9
      if (rollInFrame === 1){
        if (knockedNow === 10){
          fr.r1 = 10;
          setMessage('STRIKE! (Press Enter for next frame)');
          if (frame < 10){ frame++; newFrame(); }
        } else {
          fr.r1 = knockedNow;
          rollInFrame = 2;
          setMessage(`${knockedNow} pin${knockedNow===1?'':'s'} ‚Äî Roll 2: adjust & SPACE`);
          ball = makeBall();
        }
      } else {
        const r2 = Math.max(0, Math.min(10 - (fr.r1||0), knockedNow - (fr.r1||0)));
        fr.r2 = r2;
        if ((fr.r1||0) + r2 === 10) setMessage('SPARE! (Press Enter for next frame)');
        else setMessage(`${(fr.r1||0)+r2} pins this frame (Press Enter for next frame)`);
        if (frame < 10){ frame++; newFrame(); }
      }
    } else {
      // 10th frame
      if (rollInFrame === 1){
        fr.r1 = knockedNow;
        if (knockedNow === 10){
          setMessage('10th: STRIKE! Two more balls.');
          pins = makePins();
        } else {
          setMessage(`10th: ${knockedNow} ‚Äî Roll 2`);
        }
        rollInFrame = 2;
        ball = makeBall();
      } else if (rollInFrame === 2){
        if (fr.r1 === 10){
          fr.r2 = knockedNow; // 0..10
          setMessage('10th: Ball 2 done ‚Äî Final bonus ball.');
          pins = makePins();
          rollInFrame = 3;
        } else {
          const r2 = Math.max(0, Math.min(10 - (fr.r1||0), knockedNow - (fr.r1||0)));
          fr.r2 = r2;
          if ((fr.r1||0) + r2 === 10){
            setMessage('10th: SPARE! One bonus ball.');
            pins = makePins();
            rollInFrame = 3;
          } else {
            setMessage('10th: Frame complete. Game Over ‚Äî press N for a new game');
            rollInFrame = 3; // complete (no bonus)
          }
        }
        ball = makeBall();
      } else {
        fr.r3 = knockedNow;
        setMessage('10th: Game Over ‚Äî press N for a new game');
      }
    }
  }

  function recomputeScore(){
    totalScore = 0;
    for (let i = 0; i < 10; i++){
      const fr = frames[i];
      if (i < 9) {
        const r1 = fr.r1 ?? null, r2 = fr.r2 ?? null;
        if (r1 == null) break;
        if (r1 === 10) {
          const bonus = sumNextRolls(i, 2);
          if (bonus == null) break;
          totalScore += 10 + bonus;
        } else if (r2 != null) {
          if (r1 + r2 === 10) {
            const bonus = sumNextRolls(i, 1);
            if (bonus == null) break;
            totalScore += 10 + bonus;
          } else {
            totalScore += r1 + r2;
          }
        } else break;
      } else {
        const r1 = fr.r1 ?? 0, r2 = fr.r2 ?? 0, r3 = fr.r3 ?? 0;
        totalScore += r1 + r2 + r3;
      }
    }
  }

  function sumNextRolls(i, n){
    const rolls = [];
    for (let f = i+1; f < 10; f++){
      const fr = frames[f];
      if (fr.r1 != null) rolls.push(fr.r1);
      if (rolls.length >= n) break;
      if (fr.r2 != null) rolls.push(fr.r2);
      if (rolls.length >= n) break;
      if (f === 9 && fr.r3 != null) rolls.push(fr.r3);
      if (rolls.length >= n) break;
    }
    if (rolls.length < n) return null;
    return rolls.slice(0, n).reduce((a,b)=>a+b,0);
  }

  function isFrameComplete(idx){
    const fr = frames[idx];
    if (idx < 9) return (fr.r1 === 10) || (fr.r1 != null && fr.r2 != null);
    if (fr.r1 == null) return false;
    if (fr.r1 === 10) return fr.r2 != null && fr.r3 != null;
    if (fr.r2 == null) return false;
    if (fr.r1 + fr.r2 === 10) return fr.r3 != null;
    return true;
  }

  // DRAWING
  function drawBackground(ctx){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#0b1b34'); g.addColorStop(1, '#193a60');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawLane(ctx){
    ctx.fillStyle = '#0a1020';
    ctx.fillRect(120,80,40,440);
    ctx.fillRect(640,80,40,440);

    const laneGrad = ctx.createLinearGradient(160,520,640,80);
    laneGrad.addColorStop(0,'#d9a86c'); laneGrad.addColorStop(1,'#c58b49');
    ctx.fillStyle = laneGrad;
    ctx.fillRect(160,80,480,440);

    ctx.fillStyle = '#8b5e34';
    ctx.fillRect(160,520,480,24);

    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.setLineDash([8,12]);
    ctx.beginPath(); ctx.moveTo(400,520); ctx.lineTo(400,92); ctx.stroke();
    ctx.setLineDash([]);

    ctx.save(); ctx.translate(160,72);
    for (let i=0;i<16;i++){ const x=(i/15)*480;
      ctx.fillStyle = ['#ffd166','#ef476f','#06d6a0','#118ab2'][i%4];
      ctx.beginPath(); ctx.arc(x,0,4,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawPins(ctx, ps){
    for (const p of ps){
      ctx.save(); ctx.translate(p.x, p.y);
      if (p.knocked) ctx.rotate((p.vx+p.vy)*0.08);
      roundRect(ctx,-10,-24,20,44,10);
      ctx.fillStyle = '#fff2e0'; ctx.fill();
      ctx.fillStyle = '#d1495b'; ctx.beginPath(); ctx.moveTo(0,-32); ctx.lineTo(12,-16); ctx.lineTo(-12,-16); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(0,-32,3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#42312a'; ctx.beginPath(); ctx.arc(-4,-8,1.5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4,-8,1.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#42312a'; ctx.beginPath(); ctx.arc(0,-2,5,0,Math.PI,false); ctx.stroke();
      ctx.fillStyle = '#2a9d8f'; ctx.fillRect(-10,2,20,6);
      ctx.fillStyle = '#f4a261'; ctx.fillRect(-3,3,6,4);
      ctx.restore();
    }
  }

  function drawBall(ctx, b){
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(0, b.r*0.6, b.r*1.1, b.r*0.4, 0, 0, Math.PI*2); ctx.fill();
    const g = ctx.createRadialGradient(-6,-6,2, 0,0,b.r);
    g.addColorStop(0,'#ffffff'); g.addColorStop(1,'#e6ecf6');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#2b4a73'; ctx.beginPath(); ctx.arc(0,0,b.r*0.55,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#7fb3e4'; ctx.beginPath(); ctx.arc(0,0,b.r*0.35,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0b1730'; ctx.beginPath(); ctx.arc(4,-2,b.r*0.22,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(8,-6,b.r*0.09,0,Math.PI*2); ctx.fill();
    roundRect(ctx,-18,-24,36,12,6); ctx.fillStyle = '#365b2c'; ctx.fill();
    ctx.fillStyle = '#4a7a3a'; ctx.beginPath(); ctx.arc(18,-18,5,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#c33'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-2,6,10,0,Math.PI*0.7,false); ctx.stroke();
    ctx.restore();
  }

  function drawHUD(ctx){
    ctx.save(); ctx.fillStyle = '#ffffff'; ctx.font = '14px Inter, system-ui, sans-serif';
    ctx.fillText('Aim: ' + (aim|0) + '¬∞', 10, 20);
    ctx.fillText('Power: ' + power + '%', 10, 40);
    ctx.fillText('Score: ' + totalScore, 10, 60);
    ctx.fillText('Frame ' + frame + ' / 10  ‚Ä¢  Roll ' + rollInFrame, 10, 80);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  function makePins(){
    const ps = []; const sx = 400, sy = 140, spacing = 34;
    for (let row=0; row<4; row++){
      for (let i=0; i<=row; i++){
        const x = sx - row*(spacing/2) + i*spacing;
        const y = sy + row*spacing;
        ps.push({ x, y, r:12, knocked:false, vx:0, vy:0 });
      }
    }
    return ps;
  }

  // scoring helpers
  function recomputeScore(){
    totalScore = 0;
    for (let i = 0; i < 10; i++){
      const fr = frames[i];
      if (i < 9) {
        const r1 = fr.r1 ?? null, r2 = fr.r2 ?? null;
        if (r1 == null) break;
        if (r1 === 10) {
          const bonus = sumNextRolls(i, 2);
          if (bonus == null) break;
          totalScore += 10 + bonus;
        } else if (r2 != null) {
          if (r1 + r2 === 10) {
            const bonus = sumNextRolls(i, 1);
            if (bonus == null) break;
            totalScore += 10 + bonus;
          } else {
            totalScore += r1 + r2;
          }
        } else break;
      } else {
        const r1 = fr.r1 ?? 0, r2 = fr.r2 ?? 0, r3 = fr.r3 ?? 0;
        totalScore += r1 + r2 + r3;
      }
    }
  }

  function sumNextRolls(i, n){
    const rolls = [];
    for (let f = i+1; f < 10; f++){
      const fr = frames[f];
      if (fr.r1 != null) rolls.push(fr.r1);
      if (rolls.length >= n) break;
      if (fr.r2 != null) rolls.push(fr.r2);
      if (rolls.length >= n) break;
      if (f === 9 && fr.r3 != null) rolls.push(fr.r3);
      if (rolls.length >= n) break;
    }
    if (rolls.length < n) return null;
    return rolls.slice(0, n).reduce((a,b)=>a+b,0);
  }

  function isFrameComplete(idx){
    const fr = frames[idx];
    if (idx < 9) return (fr.r1 === 10) || (fr.r1 != null && fr.r2 != null);
    if (fr.r1 == null) return false;
    if (fr.r1 === 10) return fr.r2 != null && fr.r3 != null;
    if (fr.r2 == null) return false;
    if (fr.r1 + fr.r2 === 10) return fr.r3 != null;
    return true;
  }

  function handleRoll(knockedNow, standing){
    const fi = frame - 1;
    const fr = frames[fi];

    if (frame <= 9){
      if (rollInFrame === 1){
        if (knockedNow === 10){
          fr.r1 = 10; setMessage('STRIKE! (Press Enter for next frame)');
          if (frame < 10){ frame++; newFrame(); }
        } else {
          fr.r1 = knockedNow; rollInFrame = 2;
          setMessage(`${knockedNow} pin${knockedNow===1?'':'s'} ‚Äî Roll 2: adjust & SPACE`);
          ball = makeBall();
        }
      } else {
        const r2 = Math.max(0, Math.min(10 - (fr.r1||0), knockedNow - (fr.r1||0)));
        fr.r2 = r2;
        if ((fr.r1||0) + r2 === 10) setMessage('SPARE! (Press Enter for next frame)');
        else setMessage(`${(fr.r1||0)+r2} pins this frame (Press Enter for next frame)`);
        if (frame < 10){ frame++; newFrame(); }
      }
    } else {
      if (rollInFrame === 1){
        fr.r1 = knockedNow;
        if (knockedNow === 10){ setMessage('10th: STRIKE! Two more balls.'); pins = makePins(); }
        else setMessage(`10th: ${knockedNow} ‚Äî Roll 2`);
        rollInFrame = 2; ball = makeBall();
      } else if (rollInFrame === 2){
        if (fr.r1 === 10){
          fr.r2 = knockedNow;
          setMessage('10th: Ball 2 done ‚Äî Final bonus ball.');
          pins = makePins(); rollInFrame = 3;
        } else {
          const r2 = Math.max(0, Math.min(10 - (fr.r1||0), knockedNow - (fr.r1||0)));
          fr.r2 = r2;
          if ((fr.r1||0) + r2 === 10){ setMessage('10th: SPARE! One bonus ball.'); pins = makePins(); rollInFrame = 3; }
          else { setMessage('10th: Frame complete. Game Over ‚Äî press N for a new game'); rollInFrame = 3; }
        }
        ball = makeBall();
      } else {
        fr.r3 = knockedNow; setMessage('10th: Game Over ‚Äî press N for a new game');
      }
    }
  }

  // DRAWING
  function drawBackground(ctx){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#0b1b34'); g.addColorStop(1, '#193a60');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawLane(ctx){
    ctx.fillStyle = '#0a1020';
    ctx.fillRect(120,80,40,440);
    ctx.fillRect(640,80,40,440);

    const laneGrad = ctx.createLinearGradient(160,520,640,80);
    laneGrad.addColorStop(0,'#d9a86c'); laneGrad.addColorStop(1,'#c58b49');
    ctx.fillStyle = laneGrad; ctx.fillRect(160,80,480,440);

    ctx.fillStyle = '#8b5e34'; ctx.fillRect(160,520,480,24);

    ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.setLineDash([8,12]);
    ctx.beginPath(); ctx.moveTo(400,520); ctx.lineTo(400,92); ctx.stroke(); ctx.setLineDash([]);

    ctx.save(); ctx.translate(160,72);
    for (let i=0;i<16;i++){ const x=(i/15)*480;
      ctx.fillStyle = ['#ffd166','#ef476f','#06d6a0','#118ab2'][i%4];
      ctx.beginPath(); ctx.arc(x,0,4,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawPins(ctx, ps){
    for (const p of ps){
      ctx.save(); ctx.translate(p.x, p.y);
      if (p.knocked) ctx.rotate((p.vx+p.vy)*0.08);
      roundRect(ctx,-10,-24,20,44,10); ctx.fillStyle = '#fff2e0'; ctx.fill();
      ctx.fillStyle = '#d1495b'; ctx.beginPath(); ctx.moveTo(0,-32); ctx.lineTo(12,-16); ctx.lineTo(-12,-16); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(0,-32,3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#42312a'; ctx.beginPath(); ctx.arc(-4,-8,1.5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4,-8,1.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#42312a'; ctx.beginPath(); ctx.arc(0,-2,5,0,Math.PI,false); ctx.stroke();
      ctx.fillStyle = '#2a9d8f'; ctx.fillRect(-10,2,20,6);
      ctx.fillStyle = '#f4a261'; ctx.fillRect(-3,3,6,4);
      ctx.restore();
    }
  }

  function drawBall(ctx, b){
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(0, b.r*0.6, b.r*1.1, b.r*0.4, 0, 0, Math.PI*2); ctx.fill();
    const g = ctx.createRadialGradient(-6,-6,2, 0,0,b.r);
    g.addColorStop(0,'#ffffff'); g.addColorStop(1,'#e6ecf6');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#2b4a73'; ctx.beginPath(); ctx.arc(0,0,b.r*0.55,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#7fb3e4'; ctx.beginPath(); ctx.arc(0,0,b.r*0.35,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0b1730'; ctx.beginPath(); ctx.arc(4,-2,b.r*0.22,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(8,-6,b.r*0.09,0,Math.PI*2); ctx.fill();
    roundRect(ctx,-18,-24,36,12,6); ctx.fillStyle = '#365b2c'; ctx.fill();
    ctx.fillStyle = '#4a7a3a'; ctx.beginPath(); ctx.arc(18,-18,5,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#c33'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-2,6,10,0,Math.PI*0.7,false); ctx.stroke();
    ctx.restore();
  }

  function drawHUD(ctx){
    ctx.save(); ctx.fillStyle = '#ffffff'; ctx.font = '14px Inter, system-ui, sans-serif';
    ctx.fillText('Aim: ' + (aim|0) + '¬∞', 10, 20);
    ctx.fillText('Power: ' + power + '%', 10, 40);
    ctx.fillText('Score: ' + totalScore, 10, 60);
    ctx.fillText('Frame ' + frame + ' / 10  ‚Ä¢  Roll ' + rollInFrame, 10, 80);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // start
  newGame();
  updateHUD();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
